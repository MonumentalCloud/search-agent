#!/usr/bin/env python
"""
Test script to verify memory updates are working correctly.
"""

import os
import sys
import json
from datetime import datetime

# Add project root to path
project_root = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, project_root)

from adapters.weaviate_adapter import WeaviateClient
from memory.stores import get_chunk_stats, CHUNK_STATS
from agent.nodes.memory_updater import update_memory

def test_memory_updates():
    """Test memory updates for chunks."""
    print("Testing memory updates...")
    
    # Connect to Weaviate
    client = WeaviateClient()
    try:
        client._connect()
        client._connected = True  # Manually set the connected flag
        print("Connected to Weaviate")
    except Exception as e:
        print(f"Failed to connect to Weaviate: {e}")
        return
    
    # Get a few random chunks to use for testing
    chunks = client.hybrid_search("test", alpha=0.5, limit=3)
    if not chunks:
        print("No chunks found in Weaviate")
        return
    
    print(f"Found {len(chunks)} chunks for testing")
    
    # Create a mock answer and verdict
    mock_answer = {
        "text": "This is a test answer that would be generated by the answerer.",
        "citations": [{"chunk_id": chunk.get("chunk_id"), "text": chunk.get("body", "")[:50]} for chunk in chunks]
    }
    
    mock_verdict = {
        "valid": True,
        "confidence": 0.95,
        "intent": "test_intent",
        "reason": "Test memory updates",
        "query": "test query for centroid calculation"  # Add query for centroid calculation
    }
    
    # Print initial stats
    print("\nInitial chunk stats:")
    for chunk in chunks:
        chunk_id = chunk.get("chunk_id")
        if not chunk_id:
            continue
        
        # Get current stats from Weaviate
        import weaviate
        from weaviate.classes.query import Filter
        
        # Get collection and filter
        collection = client._client.collections.get(client.chunk_class)
        where_filter = Filter.by_property("chunk_id").equal(chunk_id)
        
        # Fetch objects
        results = collection.query.fetch_objects(
            limit=1,
            filters=where_filter
        )
        
        if results.objects:
            props = results.objects[0].properties
            print(f"Chunk {chunk_id}:")
            print(f"  useful_count: {props.get('useful_count', 0)}")
            print(f"  last_useful_at: {props.get('last_useful_at', 'None')}")
            print(f"  intent_hist: {props.get('intent_hist', {})}")
            print(f"  entity_hist: {props.get('entity_hist', {})}")
            
            # Check if query_centroid exists
            query_centroid = props.get('query_centroid')
            if query_centroid:
                print(f"  query_centroid: [vector with {len(query_centroid)} dimensions]")
            else:
                print(f"  query_centroid: None")
    
    # Update memory
    print("\nUpdating memory...")
    update_memory(mock_answer, chunks, mock_verdict)
    
    # Print updated stats from in-memory store
    print("\nUpdated in-memory chunk stats:")
    for chunk in chunks:
        chunk_id = chunk.get("chunk_id")
        if not chunk_id or chunk_id not in CHUNK_STATS:
            continue
        
        stats = CHUNK_STATS[chunk_id]
        print(f"Chunk {chunk_id}:")
        print(f"  useful_count: {stats.useful_count}")
        print(f"  last_useful_at: {stats.last_useful_at}")
        print(f"  intent_hist: {stats.intent_hist}")
        print(f"  entity_hist: {stats.entity_hist}")
        
        # Check if query_centroid exists (legacy)
        if stats.query_centroid and len(stats.query_centroid) > 0:
            print(f"  query_centroid (legacy): [vector with {len(stats.query_centroid)} dimensions]")
        else:
            print(f"  query_centroid (legacy): None")
            
        # Check for multiple query centroids
        if stats.query_centroids and len(stats.query_centroids) > 0:
            print(f"  query_centroids: {len(stats.query_centroids)} clusters")
            for i, cluster in enumerate(stats.query_centroids):
                print(f"    Cluster #{i+1}: count={cluster.count}, last_updated={cluster.last_updated}")
                print(f"      centroid: [vector with {len(cluster.centroid)} dimensions]")
                if cluster.sample_queries:
                    print(f"      sample queries: {cluster.sample_queries}")
        else:
            print(f"  query_centroids: None")
    
    # Print updated stats from Weaviate
    print("\nVerifying Weaviate persistence:")
    for chunk in chunks:
        chunk_id = chunk.get("chunk_id")
        if not chunk_id:
            continue
        
        # Get updated stats from Weaviate
        collection = client._client.collections.get(client.chunk_class)
        where_filter = Filter.by_property("chunk_id").equal(chunk_id)
        
        results = collection.query.fetch_objects(
            limit=1,
            filters=where_filter
        )
        
        if results.objects:
            props = results.objects[0].properties
            print(f"Chunk {chunk_id}:")
            print(f"  useful_count: {props.get('useful_count', 0)}")
            print(f"  last_useful_at: {props.get('last_useful_at', 'None')}")
            print(f"  intent_hist: {props.get('intent_hist', {})}")
            print(f"  entity_hist: {props.get('entity_hist', {})}")
            
            # Check if query_centroid exists
            query_centroid = props.get('query_centroid')
            if query_centroid:
                print(f"  query_centroid: [vector with {len(query_centroid)} dimensions]")
            else:
                print(f"  query_centroid: None")

if __name__ == "__main__":
    test_memory_updates()
